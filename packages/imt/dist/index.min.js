/**
 * @module @zk-kit/imt
 * @version 2.0.0-beta.1
 * @file Incremental Merkle tree implementations in TypeScript.
 * @copyright Ethereum Foundation 2024
 * @license MIT
 * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/imt}
*/
var zkKitImt=function(e){"use strict";function t(e,t,...s){if(void 0===e)throw new TypeError(`Parameter '${t}' is not defined`);if(!s.includes(typeof e))throw new TypeError(`Parameter '${t}' is none of these types: ${s.join(", ")}`)}function s(e,t){if(void 0===e)throw new TypeError(`Parameter '${t}' is not defined`)}function i(e,t){if("number"!=typeof e)throw new TypeError(`Parameter '${t}' is not a number`)}function o(e,t){if("object"!=typeof e&&!Array.isArray(e))throw new TypeError(`Parameter '${t}' is not an array`)}return e.IMT=class{constructor(e,s,i,o=2,r=[]){var n;if(t(e,"hash","function"),t(s,"depth","number"),t(i,"zeroValue","number","string","bigint"),t(o,"arity","number"),t(r,"leaves","object"),r.length>Math.pow(o,s))throw new Error(`The tree cannot contain more than ${Math.pow(o,s)} leaves`);this._hash=e,this._depth=s,this._zeroes=[],this._nodes=[],this._arity=o;for(let t=0;t<s;t+=1)this._zeroes.push(i),this._nodes[t]=[],i=e(Array(this._arity).fill(i));if(this._nodes[s]=[],r.length>0){this._nodes[0]=r;for(let t=0;t<s;t+=1)for(let s=0;s<Math.ceil(this._nodes[t].length/o);s+=1){const i=s*o,r=[];for(let e=0;e<o;e+=1)r.push(null!==(n=this._nodes[t][i+e])&&void 0!==n?n:this.zeroes[t]);this._nodes[t+1][s]=e(r)}}else this._nodes[s][0]=i;Object.freeze(this._zeroes),Object.freeze(this._nodes)}setNodes(e){this._nodes=e}get root(){return this._nodes[this.depth][0]}get depth(){return this._depth}get leaves(){return this._nodes[0].slice()}get nodes(){return this._nodes}get zeroes(){return this._zeroes}get arity(){return this._arity}indexOf(e){return t(e,"leaf","number","string","bigint"),this._nodes[0].indexOf(e)}insert(e){if(t(e,"leaf","number","string","bigint"),this._nodes[0].length>=Math.pow(this.arity,this.depth))throw new Error("The tree is full");let s=e,i=this._nodes[0].length;for(let e=0;e<this.depth;e+=1){const t=i-i%this.arity,o=t+this.arity,r=[];this._nodes[e][i]=s;for(let s=t;s<o;s+=1)s<this._nodes[e].length?r.push(this._nodes[e][s]):r.push(this._zeroes[e]);s=this._hash(r),i=Math.floor(i/this.arity)}this._nodes[this.depth][0]=s}delete(e){this.update(e,this.zeroes[0])}update(e,s){if(t(e,"index","number"),e<0||e>=this._nodes[0].length)throw new Error("The leaf does not exist in this tree");let i=s;for(let t=0;t<this.depth;t+=1){const s=e-e%this.arity,o=s+this.arity,r=[];this._nodes[t][e]=i;for(let e=s;e<o;e+=1)e<this._nodes[t].length?r.push(this._nodes[t][e]):r.push(this.zeroes[t]);i=this._hash(r),e=Math.floor(e/this.arity)}this._nodes[this.depth][0]=i}createProof(e){if(t(e,"index","number"),e<0||e>=this._nodes[0].length)throw new Error("The leaf does not exist in this tree");const s=[],i=[],o=e;for(let t=0;t<this.depth;t+=1){const o=e%this.arity,r=e-o,n=r+this.arity;i[t]=o,s[t]=[];for(let i=r;i<n;i+=1)i!==e&&(i<this._nodes[t].length?s[t].push(this._nodes[t][i]):s[t].push(this.zeroes[t]));e=Math.floor(e/this.arity)}return{root:this.root,leaf:this._nodes[0][o],pathIndices:i,siblings:s,leafIndex:o}}verifyProof(e){t(e,"proof","object"),t(e.root,"proof.root","number","string","bigint"),t(e.leaf,"proof.leaf","number","string","bigint"),t(e.siblings,"proof.siblings","object"),t(e.pathIndices,"proof.pathElements","object");let s=e.leaf;for(let t=0;t<e.siblings.length;t+=1){const i=e.siblings[t].slice();i.splice(e.pathIndices[t],0,s),s=this._hash(i)}return e.root===s}},e.LeanIMT=class{constructor(e,t=[]){s(e,"hash"),function(e,t){if("function"!=typeof e)throw new TypeError(`Parameter '${t}' is not a function`)}(e,"hash"),o(t,"leaves"),this._nodes=[[]],this._hash=e,t.length>0&&this.insertMany(t)}get root(){return this._nodes[this.depth][0]}get depth(){return this._nodes.length-1}get leaves(){return this._nodes[0].slice()}get size(){return this._nodes[0].length}indexOf(e){return s(e,"leaf"),this._nodes[0].indexOf(e)}has(e){return s(e,"leaf"),this._nodes[0].includes(e)}insert(e){s(e,"leaf"),this.depth<Math.ceil(Math.log2(this.size+1))&&this._nodes.push([]);let t=e,i=this.size;for(let e=0;e<this.depth;e+=1){if(this._nodes[e][i]=t,1&i){const s=this._nodes[e][i-1];t=this._hash(s,t)}i>>=1}this._nodes[this.depth]=[t]}insertMany(e){if(s(e,"leaves"),o(e,"leaves"),0===e.length)throw new Error("There are no leaves to add");let t=this.size>>1;this._nodes[0].push(...e);const i=Math.ceil(Math.log2(this.size))-this.depth;for(let e=0;e<i;e+=1)this._nodes.push([]);for(let e=0;e<this.depth;e+=1){const s=Math.ceil(this._nodes[e].length/2);for(let i=t;i<s;i+=1){const t=this._nodes[e][2*i+1],s=this._nodes[e][2*i],o=t?this._hash(s,t):s;this._nodes[e+1][i]=o}t>>=1}}update(e,t){s(e,"index"),s(t,"newLeaf"),i(e,"index");let o=t;for(let t=0;t<this.depth;t+=1){if(this._nodes[t][e]=o,1&e){const s=this._nodes[t][e-1];o=this._hash(s,o)}else{const s=this._nodes[t][e+1];s&&(o=this._hash(o,s))}e>>=1}this._nodes[this.depth]=[o]}generateProof(e){if(s(e,"index"),i(e,"index"),e<0||e>=this.size)throw new Error(`The leaf at index '${e}' does not exist in this tree`);const t=this.leaves[e],o=[],r=[];for(let t=0;t<this.depth;t+=1){const s=1&e,i=s?e-1:e+1,n=this._nodes[t][i];void 0!==n&&(r.push(s),o.push(n)),e>>=1}return{root:this.root,leaf:t,index:Number.parseInt(r.reverse().join(""),2),siblings:o}}verifyProof(e){s(e,"proof");const{root:t,leaf:r,siblings:n,index:h}=e;s(e.root,"proof.root"),s(e.leaf,"proof.leaf"),s(e.siblings,"proof.siblings"),s(e.index,"proof.index"),o(e.siblings,"proof.siblings"),i(e.index,"proof.index");let a=r;for(let e=0;e<n.length;e+=1)a=h>>e&1?this._hash(n[e],a):this._hash(a,n[e]);return t===a}export(){return JSON.stringify(this._nodes,((e,t)=>"bigint"==typeof t?t.toString():t))}import(e){if(s(e,"nodes"),function(e,t){if("string"!=typeof e)throw new TypeError(`Parameter '${t}' is not a string`)}(e,"nodes"),0!==this.size)throw new Error("Import failed: the target tree structure is not empty");this._nodes=JSON.parse(e)}},e}({});
