/**
 * @module @zk-kit/imt
 * @version 2.0.0-beta.1
 * @file Incremental Merkle tree implementations in TypeScript.
 * @copyright Ethereum Foundation 2024
 * @license MIT
 * @see [Github]{@link https://github.com/privacy-scaling-explorations/zk-kit/tree/main/packages/imt}
*/
var zkKitImt=function(t){"use strict";function e(t,e,...s){if(void 0===t)throw new TypeError(`Parameter '${e}' is not defined`);if(!s.includes(typeof t))throw new TypeError(`Parameter '${e}' is none of these types: ${s.join(", ")}`)}function s(t,e){if(void 0===t)throw new TypeError(`Parameter '${e}' is not defined`)}function i(t,e){if("number"!=typeof t)throw new TypeError(`Parameter '${e}' is not a number`)}function o(t,e){if("object"!=typeof t&&!Array.isArray(t))throw new TypeError(`Parameter '${e}' is not an array`)}return t.IMT=class{constructor(t,s,i,o=2,r=[]){var n;if(e(t,"hash","function"),e(s,"depth","number"),e(i,"zeroValue","number","string","bigint"),e(o,"arity","number"),e(r,"leaves","object"),r.length>Math.pow(o,s))throw new Error(`The tree cannot contain more than ${Math.pow(o,s)} leaves`);this._hash=t,this._depth=s,this._zeroes=[],this._nodes=[],this._arity=o;for(let e=0;e<s;e+=1)this._zeroes.push(i),this._nodes[e]=[],i=t(Array(this._arity).fill(i));if(this._nodes[s]=[],r.length>0){this._nodes[0]=r;for(let e=0;e<s;e+=1)for(let s=0;s<Math.ceil(this._nodes[e].length/o);s+=1){const i=s*o,r=[];for(let t=0;t<o;t+=1)r.push(null!==(n=this._nodes[e][i+t])&&void 0!==n?n:this.zeroes[e]);this._nodes[e+1][s]=t(r)}}else this._nodes[s][0]=i;Object.freeze(this._zeroes),Object.freeze(this._nodes)}get root(){return this._nodes[this.depth][0]}get depth(){return this._depth}get leaves(){return this._nodes[0].slice()}get nodes(){return this._nodes}get zeroes(){return this._zeroes}get arity(){return this._arity}indexOf(t){return e(t,"leaf","number","string","bigint"),this._nodes[0].indexOf(t)}insert(t){if(e(t,"leaf","number","string","bigint"),this._nodes[0].length>=Math.pow(this.arity,this.depth))throw new Error("The tree is full");let s=t,i=this._nodes[0].length;for(let t=0;t<this.depth;t+=1){const e=i-i%this.arity,o=e+this.arity,r=[];this._nodes[t][i]=s;for(let s=e;s<o;s+=1)s<this._nodes[t].length?r.push(this._nodes[t][s]):r.push(this._zeroes[t]);s=this._hash(r),i=Math.floor(i/this.arity)}this._nodes[this.depth][0]=s}delete(t){this.update(t,this.zeroes[0])}update(t,s){if(e(t,"index","number"),t<0||t>=this._nodes[0].length)throw new Error("The leaf does not exist in this tree");let i=s;for(let e=0;e<this.depth;e+=1){const s=t-t%this.arity,o=s+this.arity,r=[];this._nodes[e][t]=i;for(let t=s;t<o;t+=1)t<this._nodes[e].length?r.push(this._nodes[e][t]):r.push(this.zeroes[e]);i=this._hash(r),t=Math.floor(t/this.arity)}this._nodes[this.depth][0]=i}createProof(t){if(e(t,"index","number"),t<0||t>=this._nodes[0].length)throw new Error("The leaf does not exist in this tree");const s=[],i=[],o=t;for(let e=0;e<this.depth;e+=1){const o=t%this.arity,r=t-o,n=r+this.arity;i[e]=o,s[e]=[];for(let i=r;i<n;i+=1)i!==t&&(i<this._nodes[e].length?s[e].push(this._nodes[e][i]):s[e].push(this.zeroes[e]));t=Math.floor(t/this.arity)}return{root:this.root,leaf:this._nodes[0][o],pathIndices:i,siblings:s,leafIndex:o}}verifyProof(t){e(t,"proof","object"),e(t.root,"proof.root","number","string","bigint"),e(t.leaf,"proof.leaf","number","string","bigint"),e(t.siblings,"proof.siblings","object"),e(t.pathIndices,"proof.pathElements","object");let s=t.leaf;for(let e=0;e<t.siblings.length;e+=1){const i=t.siblings[e].slice();i.splice(t.pathIndices[e],0,s),s=this._hash(i)}return t.root===s}},t.LeanIMT=class{constructor(t,e=[]){s(t,"hash"),function(t,e){if("function"!=typeof t)throw new TypeError(`Parameter '${e}' is not a function`)}(t,"hash"),o(e,"leaves"),this._nodes=[[]],this._hash=t,e.length>0&&this.insertMany(e)}get root(){return this._nodes[this.depth][0]}get depth(){return this._nodes.length-1}get leaves(){return this._nodes[0].slice()}get size(){return this._nodes[0].length}indexOf(t){return s(t,"leaf"),this._nodes[0].indexOf(t)}has(t){return s(t,"leaf"),this._nodes[0].includes(t)}insert(t){s(t,"leaf"),this.depth<Math.ceil(Math.log2(this.size+1))&&this._nodes.push([]);let e=t,i=this.size;for(let t=0;t<this.depth;t+=1){if(this._nodes[t][i]=e,1&i){const s=this._nodes[t][i-1];e=this._hash(s,e)}i>>=1}this._nodes[this.depth]=[e]}insertMany(t){if(s(t,"leaves"),o(t,"leaves"),0===t.length)throw new Error("There are no leaves to add");let e=this.size>>1;this._nodes[0].push(...t);const i=Math.ceil(Math.log2(this.size))-this.depth;for(let t=0;t<i;t+=1)this._nodes.push([]);for(let t=0;t<this.depth;t+=1){const s=Math.ceil(this._nodes[t].length/2);for(let i=e;i<s;i+=1){const e=this._nodes[t][2*i+1],s=this._nodes[t][2*i],o=e?this._hash(s,e):s;this._nodes[t+1][i]=o}e>>=1}}update(t,e){s(t,"index"),s(e,"newLeaf"),i(t,"index");let o=e;for(let e=0;e<this.depth;e+=1){if(this._nodes[e][t]=o,1&t){const s=this._nodes[e][t-1];o=this._hash(s,o)}else{const s=this._nodes[e][t+1];s&&(o=this._hash(o,s))}t>>=1}this._nodes[this.depth]=[o]}generateProof(t){if(s(t,"index"),i(t,"index"),t<0||t>=this.size)throw new Error(`The leaf at index '${t}' does not exist in this tree`);const e=this.leaves[t],o=[],r=[];for(let e=0;e<this.depth;e+=1){const s=1&t,i=s?t-1:t+1,n=this._nodes[e][i];void 0!==n&&(r.push(s),o.push(n)),t>>=1}return{root:this.root,leaf:e,index:Number.parseInt(r.reverse().join(""),2),siblings:o}}verifyProof(t){s(t,"proof");const{root:e,leaf:r,siblings:n,index:h}=t;s(t.root,"proof.root"),s(t.leaf,"proof.leaf"),s(t.siblings,"proof.siblings"),s(t.index,"proof.index"),o(t.siblings,"proof.siblings"),i(t.index,"proof.index");let a=r;for(let t=0;t<n.length;t+=1)a=h>>t&1?this._hash(n[t],a):this._hash(a,n[t]);return e===a}export(){return JSON.stringify(this._nodes,((t,e)=>"bigint"==typeof e?e.toString():e))}import(t){if(s(t,"nodes"),function(t,e){if("string"!=typeof t)throw new TypeError(`Parameter '${e}' is not a string`)}(t,"nodes"),0!==this.size)throw new Error("Import failed: the target tree structure is not empty");this._nodes=JSON.parse(t)}},t}({});
